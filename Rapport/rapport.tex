\documentclass[a4paper,titlepage]{article}

%PACKAGES
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{mathrsfs}
\usepackage{fancyhdr}
\usepackage{lmodern}
\usepackage{graphicx}
\usepackage{geometry}
\usepackage{fancybox}
\usepackage{textcomp}

%Symbole euro
\usepackage{eurosym}

%Listings : affichage code
\usepackage{listings}


%Elements de la page de garde
\begin{document}

\begin{titlepage}

\begin{figure}
\centering
\includegraphics[width=5cm]{logo-ulg.png}
\end{figure}



\title{
\vspace{0.2cm}
\LARGE{\textbf{Second part report}} \\ \textsc{Discrete optimization}
\author{\textbf{Fabrice Servais} \small{(S111093})\\\textbf{Laurent Vanosmael} \small{(S114351}) \\ \\ Masters in Computer Science and Engineering - $1^{\text{st}}$ year}
\date{December 7, 2014}
\rule{15cm}{1.5pt}
}

%\geometry{hmargin=2.5cm}
\end{titlepage}

%DOCUMENT
\pagestyle{fancy}
\lhead{Second part report}
\rhead{Discrete optimization}

%Page de garde
\maketitle

\section{Introduction}



\section{Datas}

\begin{itemize}		
	\item $sl_{k} = \left\{ 
	\begin{array}{ll}
		1 & \text{if the key $k$ is on the left side,}\\
		0 & \text{otherwise.}\\
	\end{array}
	\right.$

	\item $sr_{k} = \left\{ 
	\begin{array}{ll}
		1 & \text{if the key $k$ is on the right side,}\\
		0 & \text{otherwise.}\\
	\end{array}
	\right.$

	\item $fr_k$ : probability of the apparition of the letter $l$ in the considered language.

	\item $v_{l} = \left\{ 
	\begin{array}{ll}
		1 & \text{if the letter $l$ is a vowel,}\\
		0 & \text{otherwise.}\\
	\end{array}
	\right.$

	\item $V$ : number of vowels in the language.

	\item $w_{i,j}$ : probability that the letter $j$ follows the letter $i$ in a word. 

	\item $ks_{k}$ : strength of the finger associated to key $k$ ($ks_k \in [0,1])$.

	\item $d_k$ : distance that the finger attributed to the key $k$ has to cross to reach that key.
\end{itemize}




\section{Model}

	\subsection{Variables}

\begin{itemize}
 	\item$kb_{k,l} = \left\{ 
	\begin{array}{ll}
		1 & \text{if the letter $l$ is on the key $k$,}\\
		0 & \text{otherwise.}\\
	\end{array}
	\right.$

	\item $vl = \left\{ 
	\begin{array}{ll}
		1 & \text{if the vowels are on the left side,}\\
		0 & \text{otherwise.}\\
	\end{array}
	\right.$

	\item $a_{i,j} = \left\{ 
	\begin{array}{ll}
		1 & \text{if to type $i$ and then $j$, it is not the same hand that is used,}\\
		0 & \text{otherwise.}\\
	\end{array}
	\right.$	
\end{itemize}

	\subsection{Constraints}

\begin{itemize}
	\item $\sum_l fr_l \cdot \left(\sum_k kb_{k,l} \cdot (sr_k - sl_k) \right) \geq 0$

	\item $\sum_k kb_{k,l} = 1 \text{, } \forall l$

	\item $\sum_l kb_{k,l} = 1 \text{, } \forall k$

	\item $\sum_l v_l \cdot \left( \sum_k kb_{k,l} \cdot sl_k \right) = V \cdot vl$

	\item $a_{i,j} = a_{j,i} \text{, } \forall i,j$

	\item $a_{i,i} = 0 \text{, } \forall i$

	\item $a_{i,j} \leq \sum_k kb_{k,i} \cdot sl_k + \sum_k kb_{k,j} \cdot sl_k$

	\item $a_{i,j} \geq \sum_k kb_{k,i} \cdot sl_k - \sum_k kb_{k,j} \cdot sl_k$

	\item $a_{i,j} \geq \sum_k kb_{k,j} \cdot sl_k - \sum_k kb_{k,i} \cdot sl_k$

	\item $a_{i,j} \leq 2 - \sum_k kb_{k,i} \cdot sl_k - \sum_k kb_{k,j} \cdot sl_k$
\end{itemize}

	\subsection{Objective function}

\[
	\min \left[ \sum_l fr_l \cdot \left( \sum_k ks_k \cdot d_k \cdot kb_{k,l}  \right) + \sum_i \sum_j w_{i,j} \cdot \left(1 - a_{i,j}\right) + \sum_i \sum_j w_{i,j} \left( \sum_k d_k \cdot kb_{k,i} + \sum_l d_l \cdot kb_{k,j} \right) \right]
\]



\section{Method}
To obtain an optimal keyboard related to our model by using the \textbf{row generation} method. To implement that method, we use 2 concepts that are present in Gurobi : the lazy constraint and the callback.
\paragraph{}
The lazy constraints are the constraints that are less likely to be violated, so they are not contained in the set of the beginning but are added as we go along the execution of the solver. In order to do that, we use the callback system. We provide a class containing a \texttt{callback()} function which is called at key steps of the resolution.
In our implementation, the function is called when the solver found a solution. This function checks if one of the lazy constraints is violated or not. If yes, we add it to the model by using the \texttt{addLazy()} function.
\paragraph{}
The constraints that are considered lazy are these one : $\forall i,j$,
\begin{itemize}
	\item $a_{i,j} \leq \sum_k kb_{k,i} \cdot sl_k + \sum_k kb_{k,j} \cdot sl_k$

	\item $a_{i,j} \geq \sum_k kb_{k,i} \cdot sl_k - \sum_k kb_{k,j} \cdot sl_k$

	\item $a_{i,j} \geq \sum_k kb_{k,j} \cdot sl_k - \sum_k kb_{k,i} \cdot sl_k$

	\item $a_{i,j} \leq 2 - \sum_k kb_{k,i} \cdot sl_k - \sum_k kb_{k,j} \cdot sl_k$
\end{itemize}
\paragraph{}



\section{Results}
\begin{tabular}{cccccccccccccccccccccccccccccccccccccccccccccc}
é & & â & & ê & & « & & ( & & » & & j & & z & & x & & f & & ô & & û & \\
 & à & & , & & ! & & : & & ? & & v & & h & & c & & s & & g & & ) & & ù\\
  & & . & & o & & u & & e & & a & & l & & t & & - & & r & & n & & b & & ç\\
î & & è & & i & & y & & \_ & & ; & & p & & ' & & m & & d & & q & & & \\
\end{tabular}

\section{Improvements}

\newpage

\end{document}








